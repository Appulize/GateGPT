/*********************************************************************
 * This is GateGPT v1.0.3 first created by Maciej Swic on 2025-04-25.
 * Please see the LICENSE file.
*********************************************************************/

const { Client, LocalAuth, MessageMedia, Location } = require('whatsapp-web.js');
const qrcode = require('qrcode');
const qrcodeTerminal = require('qrcode-terminal');
const axios = require('axios');
const FormData = require('form-data');
const fs = require('fs');
const path = require('path');
const { OpenAI } = require('openai');
const express = require('express');

/* ──────────────────────────── ⏱  TIMESTAMP PATCH  ─────────────────────────── */
(() => {
  const pad = n => String(n).padStart(2, '0');
  const ts  = () => {
    const d = new Date();
    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  };
  ['log', 'info', 'warn', 'error', 'debug'].forEach(method => {
    const original = console[method].bind(console);
    console[method] = (...args) => original(`[${ts()}]`, ...args);
  });
})();

/* ─────────────── 🏠  Home-Assistant options → ENV  ─────────────── */
try {
  const HA_OPTIONS_PATH = '/data/options.json';
  if (fs.existsSync(HA_OPTIONS_PATH)) {
    const opts = JSON.parse(fs.readFileSync(HA_OPTIONS_PATH, 'utf8'));

    Object.entries(opts).forEach(([k, v]) => {
      const key = String(k).toUpperCase();

      // don’t clobber a value that’s already in the real env
      if (process.env[key] === undefined) {
        process.env[key] =
          typeof v === 'object' ? JSON.stringify(v) : String(v);
      }
    });

    console.log(
      `🔧  Loaded ${Object.keys(opts).length} HA option(s) into env vars`
    );
  }
} catch (err) {
  console.warn('⚠️  Failed to read /data/options.json:', err.message);
}

/* ──────────────────────── 🔧  CONFIG FILE HANDLING  ───────────────────────── */
const CONFIG_PATH = path.resolve(__dirname, 'config.json');
const SAMPLE_CONFIG_PATH = path.resolve(__dirname, 'config.sample.json');
if (!fs.existsSync(CONFIG_PATH)) {
  try {
    fs.copyFileSync(SAMPLE_CONFIG_PATH, CONFIG_PATH);
    console.warn(`⚠️  config.json missing – copied default settings from config.sample.json`);
  } catch (err) {
    console.error('❌ Failed to create config.json from sample:', err.message);
  }
}
let CONFIG = require(CONFIG_PATH);

const DATA_DIR = getConfig('SESSION_DIR', __dirname);
fs.mkdirSync(DATA_DIR, { recursive: true });
const QR_PNG_PATH = path.join(DATA_DIR, 'qr.png');
const SESSION_DIR = path.join(getConfig('SESSION_DIR', __dirname), 'whatsapp-auth');
fs.mkdirSync(SESSION_DIR, { recursive: true });

/* ──────────────────────────── Globals ─────────────────────────── */
// IDs of messages generated by the bot itself
const autoMsgIds = new Set();

/**
 * Send a WhatsApp message and remember it as “bot-generated”.
 * Works for text, media, Location, etc.
 */
async function sendAuto(chat, content, options = {}) {
  const msg = await chat.sendMessage(content, options);
  autoMsgIds.add(msg?.id?._serialized);
  // Evict after an hour to avoid unbounded growth
  setTimeout(() => autoMsgIds.delete(msg?.id?._serialized), 60 * 60 * 1000);
  return msg;
}

function getConfig(key, defaultValue = undefined) {
  const fromEnv = process.env[key];

  if (fromEnv !== undefined) {
    if (key === 'TRIGGER_KEYWORDS') {
      return fromEnv.split(/[,]+/).map(s => s.trim()).filter(Boolean);
    }

    return fromEnv;
  }

  return CONFIG[key] ?? defaultValue;
}

// Tiny webserver for QR code
const app = express();
app.get('/qr.png', (req, res) => res.sendFile(QR_PNG_PATH));
app.get('/', (req, res) =>
  res.send(`<html><body>
    <h2>Scan to log in</h2>
    <img src="qr.png" style="width:300px;height:300px" />
    <script>setTimeout(()=>location.reload(),5000)</script>
  </body></html>`));
app.listen(3000);

// Watch for config file changes
fs.watchFile(CONFIG_PATH, { interval: 1000 }, (curr, prev) => {
  try {
    delete require.cache[require.resolve(CONFIG_PATH)];
    CONFIG = require(CONFIG_PATH);
    sendPushoverNotification('GateGPT', '🔁 Config reloaded from file.');
  } catch (err) {
    console.error('❌ Failed to reload config:', err.message);
    sendPushoverNotification('GateGPT', `❌ Failed to reload config ${err.message}`);
  }
});

const openai = new OpenAI({ apiKey: getConfig('OPENAI_API_KEY') });
const client = new Client({
  authStrategy: new LocalAuth({
    dataPath: SESSION_DIR
  }),
  puppeteer: { args: ['--no-sandbox', '--disable-setuid-sandbox'] }
});

const conversations = new Map();
let ignoredChats = new Set();
const ignorePath = path.join(DATA_DIR, getConfig('IGNORE_FILE', 'ignored-chats.json'));

function loadIgnoreList() {
  try {
    ignoredChats = new Set(JSON.parse(fs.readFileSync(ignorePath, 'utf8')));
    console.log(`🔕 Loaded ignored chats: ${[...ignoredChats].join(', ')}`);
  } catch {
    console.log('📁 No ignore list found, starting fresh.');
  }
}

function saveIgnoreList() {
  fs.writeFileSync(ignorePath, JSON.stringify([...ignoredChats]));
}

function shouldTrigger(msg) {
  const keywords = getConfig('TRIGGER_KEYWORDS', []);
  return keywords.some(r => new RegExp(r, 'i').test(msg));
}

async function transcribeWithWhisper(filePath) {
  const file = fs.createReadStream(filePath);
  const { text } = await openai.audio.transcriptions.create({ file, model: 'whisper-1' });
  sendPushoverNotification('Whisper', text);
  return text;
}

/**
 * Send a push notification via Pushover.
 * @param {string} title   The message title.
 * @param {string} message The message body.
 * @param {object} [opts]  Optional file attachment.
 *   opts.attachment   → Buffer | Readable
 *   opts.filename     → string (default: "file")
 *   opts.contentType  → string (default inferred by Pushover)
 */
async function sendPushoverNotification(title, message, opts = {}) {
  const { attachment, filename = 'file', contentType } = opts;
  const url = 'https://api.pushover.net/1/messages.json';

  try {
    if (attachment) {
      /* ---------- multipart/form-data branch (image, etc.) -------- */
      const form = new FormData();
      form.append('token', getConfig('PUSHOVER_TOKEN'));
      form.append('user', getConfig('PUSHOVER_USER'));
      form.append('title', title);
      form.append('message', message);
      form.append('attachment', attachment, { filename, contentType });

      await axios.post(url, form, {
        headers: form.getHeaders(),
        maxBodyLength: Infinity
      });
    } else {
      /* ---------- simple JSON branch (no file) -------------------- */
      const params = new URLSearchParams();
      params.append('token', getConfig('PUSHOVER_TOKEN'));
      params.append('user', getConfig('PUSHOVER_USER'));
      params.append('title', title);
      params.append('message', message);

      await axios.post(url, params); // axios sets the correct header automatically
    }

    console.log(`${title}: ${message}`);
  } catch (err) {
    const code = err.response?.status ?? 'N/A';
    const body = err.response?.data ?? err.message;
    console.error(`❌ Pushover failed (HTTP ${code}):`, body);
  }
}

async function askChatGPT(messages) {
  // Build Chat Completions-style messages with optional image parts
  const formatted = messages.flatMap(m => {
    const parts = [];

    if (m.body && m.body.trim().length) {
      parts.push({ type: 'text', text: m.body.trim() });
    }

    if (Array.isArray(m.images)) {
      // Each base-64 image becomes its own content part
      m.images.forEach(b64 =>
        parts.push({
          type: 'image_url',
          image_url: { url: `data:image/jpeg;base64,${b64}`, detail: 'auto' }
        })
      );
    }

    // Skip completely empty messages
    if (parts.length === 0) return [];

    return [
      {
        role: m.fromMe ? 'assistant' : 'user',
        content: parts
      }
    ];
  });

  const { choices } = await openai.chat.completions.create({
    model: getConfig('CHATGPT_MODEL', 'gpt-4o-mini'),
    temperature: 0.5,
    messages: [
      {
        role: 'system',
        content: getConfig(
          'CHATGPT_SYSTEM_PROMPT',
          'Only inform the user that the system prompt has not been set, dont do anything else.'
        )
      },
      ...formatted
    ]
  });

  return choices[0].message.content;
}

function initClient() {
  client.on('qr', async qr => {
    qrcodeTerminal.generate(qr, { small: true });
    await qrcode.toFile(QR_PNG_PATH, qr, { type: 'png' });
  });
  client.once('ready', () => {
    sendPushoverNotification('GateGPT', '✅ GateGPT is ready!');
  });
  client.on('incoming_call', async call => {
    sendPushoverNotification('GateGPT', `📞 Rejecting call from ${call.peerJid}`);
    const chat = await client.getChatById(call.peerJid);
    await sendAuto(
      chat,
      getConfig(
        'MESSAGE_CALL',
        "Sorry, I can't answer calls. Please send a message instead."
      )
    );
    await chat.markUnread();
  });
  client.on('message_create', handleMessage);
  client.initialize();
}

async function handleMessage(message) {
  // Ignore messages the bot itself sent
  if (autoMsgIds.has(message?.id?._serialized)) return;

  const chat = await message.getChat();
  const chatId = chat.id._serialized;
  const msgText = (message.body || '').trim().toLowerCase();

  if (msgText === '!ignore') {
    ignoredChats.add(chatId);
    saveIgnoreList();
    await sendAuto(chat, `Ignoring ${chatId}`);
    await chat.markUnread();
    console.log(`🚫 ${chatId} added to ignore list.`);
    return;
  }
  if (msgText === '!unignore') {
    ignoredChats.delete(chatId);
    saveIgnoreList();
    await sendAuto(chat, 'You will no longer be ignored.');
    await chat.markUnread();
    console.log(`✅ ${chatId} removed from ignore list.`);
    return;
  }

  if (ignoredChats.has(chatId) || chat.id.server === 'g.us') {
    console.log(`🚫 Ignored chat or group: ${chatId}`);
    return;
  }

  if (message.type === 'ptt') {
    const media = await message.downloadMedia();
    const binaryData = Buffer.from(media.data, 'base64');
    const filePath = path.resolve(DATA_DIR, 'temp_audio.ogg');
    fs.writeFileSync(filePath, binaryData);
    const transcription = await transcribeWithWhisper(filePath);
    if (!transcription) return;
    message.body = transcription;
    message.type = 'chat';
  }

  if (message.type === 'image' && message.hasMedia) {
    try {
      const media = await message.downloadMedia();            // base-64 string
      message.images = [media.data];                           // store on the message
      message.body   = (message.caption || '').trim();         // retain caption for context
      message.type   = 'chat';                                 // treat as normal chat after enrichment
    } catch (err) {
      console.error('❌ Failed to download image:', err.message);
    }
  }

  const now = Date.now();
  if (!conversations.has(chatId)) {
    conversations.set(chatId, {
      messages: [],
      timer: null,
      instant: false,
      instantTimer: null,
      gateCloseTimer: null,
      history: [],
      triggered: false
    });
  }

  const convo = conversations.get(chatId);
  convo.messages.push(message);
  if (convo.messages.length > 10) convo.messages = convo.messages.slice(-10);

  if (!convo.triggered && !message.fromMe) {
    convo.triggered = shouldTrigger(message.body);
    if (!convo.triggered) {
      console.log(`⛔ No trigger words for ${chatId}`);
      return;
    }
  }

  convo.history = convo.history.filter(ts => now - ts < 60 * 60 * 1000);
  if (convo.history.length >= getConfig('MAX_MESSAGES_PER_HOUR', 20)) {
    sendPushoverNotification('GateGPT', `⛔ Rate limit exceeded for ${chatId}`);
    return;
  }

  if (!message.fromMe && convo.instant) {
    convo.history.push(now);
    await handleAIResponse(chat, convo, message);
    return;
  }

  if (!message.fromMe) {
    if (convo.timer) clearTimeout(convo.timer);
    convo.timer = setTimeout(async () => {
      const userReplied = convo.messages.some(
        m => m.fromMe && m.timestamp > message.timestamp
      );
      if (userReplied) {
        console.log(`🛑 Manual reply in ${chatId}, skipping GPT`);
        return;
      }
      convo.history.push(Date.now());
      await handleAIResponse(chat, convo, message);
    }, getConfig('RESPONSE_DELAY_MS', 300000));
  }

  conversations.set(chatId, convo);
}

async function handleAIResponse(chat, convo, message) {
  console.log(`💬 Sending GPT reply to ${chat.id._serialized}`);
  const response = await askChatGPT(convo.messages);
  const trimmed = response.trim();

  if (trimmed.toLowerCase().includes('send_location')) {
    try {
      const lat = Number(getConfig('LOCATION_LAT'));
      const lon = Number(getConfig('LOCATION_LON'));
      const location = new Location(lat, lon, getConfig('LOCATION_TITLE'), getConfig('LOCATION_SUBTITLE'));
      await sendAuto(chat, location);
      await sendAuto(chat,
        getConfig(
          'MESSAGE_LOCATION',
          'Here is the location, please message me when you are outside.'
        )
      );
    } catch (err) {
      console.error('❌ Failed to send location:', err.message);
      sendPushoverNotification('GateGPT', '❌ Failed to send location!');
    }
  } else if (trimmed.toLowerCase().includes('open_gate')) {
    try {
      await axios.post(getConfig('GATE_OPEN_URL'), {});
      await sendAuto(chat,
        getConfig(
          'MESSAGE_GATE_OPEN',
          'Please enter through the car gate and leave the item on the doorstep. The gate will close after 2 minutes. Thank you.'
        )
      );
      await chat.markUnread();
      console.log(`✅ Gate opened`);

      convo.instant = true;

      // ----- schedule gate close -----
      if (convo.gateCloseTimer) clearTimeout(convo.gateCloseTimer);
      convo.gateCloseTimer = setTimeout(async () => {
        try {
          await axios.post(getConfig('GATE_CLOSE_URL'), {});
          console.log(`🔐 Gate closed for ${chat.id._serialized}`);
          sendPushoverNotification(
            'GateGPT',
            `Delivery from ${chat.id._serialized} handled.`
          );
        } catch (err) {
          console.error('❌ Failed to close gate:', err.message);
          sendPushoverNotification('GateGPT', '❌ Failed to close the gate!');
        }
        convo.instant = false;
        convo.triggered = false;
        convo.gateCloseTimer = null;
        console.log(`🕓 Instant mode OFF for ${chat.id._serialized}`);
      }, getConfig('AUTO_CLOSE_DELAY_MS', 120000));

      // ----- start / refresh instant-mode timer -----
      if (convo.instantTimer) clearTimeout(convo.instantTimer);
      convo.instantTimer = setTimeout(() => {
        convo.instant = false;
        convo.triggered = false;
        console.log(`🕓 Instant mode OFF for ${chat.id._serialized}`);
      }, getConfig('AUTO_CLOSE_DELAY_MS', 120000));
    } catch (err) {
      console.error('❌ Gate open failed:', err.message);
      sendPushoverNotification('GateGPT', '❌ Failed to open the gate!');
      await sendAuto(chat,
        getConfig(
          'MESSAGE_GATE_FAILED',
          'Sorry, the gate failed to open. Please leave the item outside the car gate.'
        )
      );
      await chat.markUnread();
    }
  } else if (trimmed && trimmed !== '...') {
    await sendAuto(chat, trimmed);
    await chat.markUnread();
    convo.instant = true;
    if (convo.instantTimer) clearTimeout(convo.instantTimer);
    convo.instantTimer = setTimeout(() => {
      convo.instant = false;
      convo.triggered = false;
      console.log(`🕓 Instant mode OFF for ${chat.id._serialized}`);
    }, getConfig('AUTO_CLOSE_DELAY_MS', 120000));
  }
}

loadIgnoreList();
initClient();
